import logger from '@wdio/logger';
import { getA11yResultsSummary, getA11yResults, getUniqueIdentifier, getUniqueIdentifierForCucumber, isAccessibilityAutomationSession, isBrowserstackSession, o11yClassErrorHandler, shouldScanTestForAccessibility, validateCapsWithA11y, isTrue, } from './util.js';
import { testForceStop, testStartEvent, testStop } from './scripts/test-event-scripts.js';
const log = logger('@wdio/browserstack-service');
class _AccessibilityHandler {
    _browser;
    _capabilities;
    _framework;
    _accessibilityAutomation;
    _accessibilityOpts;
    _platformA11yMeta;
    _caps;
    _suiteFile;
    _accessibility;
    _accessibilityOptions;
    _testMetadata = {};
    constructor(_browser, _capabilities, isAppAutomate, _framework, _accessibilityAutomation, _accessibilityOpts) {
        this._browser = _browser;
        this._capabilities = _capabilities;
        this._framework = _framework;
        this._accessibilityAutomation = _accessibilityAutomation;
        this._accessibilityOpts = _accessibilityOpts;
        const caps = this._browser.capabilities;
        this._platformA11yMeta = {
            browser_name: caps.browserName,
            browser_version: caps?.browserVersion || caps?.version || 'latest',
            os_name: this._getCapabilityValue(_capabilities, 'os', 'os'),
            os_version: this._getCapabilityValue(_capabilities, 'osVersion', 'os_version')
        };
        this._caps = _capabilities;
        this._accessibility = isTrue(_accessibilityAutomation);
        this._accessibilityOptions = _accessibilityOpts;
    }
    setSuiteFile(filename) {
        this._suiteFile = filename;
    }
    _getCapabilityValue(caps, capType, legacyCapType) {
        if (caps) {
            if (capType === 'accessibility') {
                if (caps['bstack:options'] && (isTrue(caps['bstack:options']?.accessibility))) {
                    return caps['bstack:options']?.accessibility;
                }
                else if (isTrue(caps['browserstack.accessibility'])) {
                    return caps['browserstack.accessibility'];
                }
            }
            else if (capType === 'deviceName') {
                if (caps['bstack:options'] && caps['bstack:options']?.deviceName) {
                    return caps['bstack:options']?.deviceName;
                }
                else if (caps['bstack:options'] && caps['bstack:options']?.device) {
                    return caps['bstack:options']?.device;
                }
                else if (caps['appium:deviceName']) {
                    return caps['appium:deviceName'];
                }
            }
            else if (capType === 'goog:chromeOptions' && caps['goog:chromeOptions']) {
                return caps['goog:chromeOptions'];
            }
            else {
                const bstackOptions = caps['bstack:options'];
                if (bstackOptions && bstackOptions?.[capType]) {
                    return bstackOptions?.[capType];
                }
                else if (caps[legacyCapType]) {
                    return caps[legacyCapType];
                }
            }
        }
    }
    async before() {
        this._accessibility = isTrue(this._getCapabilityValue(this._caps, 'accessibility', 'browserstack.accessibility'));
        if (isBrowserstackSession(this._browser) && isAccessibilityAutomationSession(this._accessibility)) {
            const deviceName = this._getCapabilityValue(this._caps, 'deviceName', 'device');
            const chromeOptions = this._getCapabilityValue(this._caps, 'goog:chromeOptions', '');
            this._accessibility = validateCapsWithA11y(deviceName, this._platformA11yMeta, chromeOptions);
        }
        this._browser.getAccessibilityResultsSummary = async () => {
            return await getA11yResultsSummary(this._browser, isBrowserstackSession(this._browser), this._accessibility);
        };
        this._browser.getAccessibilityResults = async () => {
            return await getA11yResults(this._browser, isBrowserstackSession(this._browser), this._accessibility);
        };
    }
    async beforeTest(suiteTitle, test) {
        if (this._framework !== 'mocha' ||
            !this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        const shouldScanTest = shouldScanTestForAccessibility(suiteTitle, test.title, this._accessibilityOptions);
        const testIdentifier = this.getIdentifier(test);
        const isPageOpened = await this.checkIfPageOpened(this._browser, testIdentifier, shouldScanTest);
        if (!isPageOpened) {
            return;
        }
        try {
            if (shouldScanTest) {
                log.info('Setup for Accessibility testing has started. Automate test case execution will begin momentarily.');
                await this.sendTestStartEvent(this._browser);
            }
            else {
                await this.sendTestForceStopEvent(this._browser);
            }
            this._testMetadata[testIdentifier].accessibilityScanStarted = shouldScanTest;
            if (shouldScanTest) {
                log.info('Automate test case execution has started.');
            }
        }
        catch (error) {
            log.error(`Exception in starting accessibility automation scan for this test case ${error}`);
        }
    }
    async afterTest(suiteTitle, test) {
        if (this._framework !== 'mocha' ||
            !this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        try {
            const testIdentifier = this.getIdentifier(test);
            const accessibilityScanStarted = this._testMetadata[testIdentifier]?.accessibilityScanStarted;
            const shouldScanTestForAccessibility = this._testMetadata[testIdentifier]?.scanTestForAccessibility;
            if (!accessibilityScanStarted) {
                return;
            }
            if (shouldScanTestForAccessibility) {
                log.info('Automate test case execution has ended. Processing for accessibility testing is underway. ');
            }
            const dataForExtension = {
                saveResults: shouldScanTestForAccessibility,
                testDetails: {
                    'name': test.title,
                    'testRunId': process.env.BS_A11Y_TEST_RUN_ID,
                    'filePath': this._suiteFile,
                    'scopeList': [suiteTitle, test.title]
                },
                platform: this._platformA11yMeta
            };
            await this.sendTestStopEvent(this._browser, dataForExtension);
            if (shouldScanTestForAccessibility) {
                log.info('Accessibility testing for this test case has ended.');
            }
        }
        catch (error) {
            log.error(`Accessibility results could not be processed for the test case ${test.title}. Error :`, error);
        }
    }
    /**
      * Cucumber Only
    */
    async beforeScenario(world) {
        if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        const pickleData = world.pickle;
        const gherkinDocument = world.gherkinDocument;
        const featureData = gherkinDocument.feature;
        const uniqueId = getUniqueIdentifierForCucumber(world);
        const shouldScanScenario = shouldScanTestForAccessibility(featureData?.name, pickleData.name, this._accessibilityOptions);
        const isPageOpened = await this.checkIfPageOpened(this._browser, uniqueId, shouldScanScenario);
        if (!isPageOpened) {
            return;
        }
        try {
            if (shouldScanScenario) {
                log.info('Setup for Accessibility testing has started. Automate test case execution will begin momentarily.');
                await this.sendTestStartEvent(this._browser);
            }
            else {
                await this.sendTestForceStopEvent(this._browser);
            }
            this._testMetadata[uniqueId].accessibilityScanStarted = shouldScanScenario;
            if (shouldScanScenario) {
                log.info('Automate test case execution has started.');
            }
        }
        catch (error) {
            log.error(`Exception in starting accessibility automation scan for this test case ${error}`);
        }
    }
    async afterScenario(world) {
        if (!this.shouldRunTestHooks(this._browser, this._accessibility)) {
            return;
        }
        const pickleData = world.pickle;
        try {
            const gherkinDocument = world.gherkinDocument;
            const featureData = gherkinDocument.feature;
            const uniqueId = getUniqueIdentifierForCucumber(world);
            const accessibilityScanStarted = this._testMetadata[uniqueId]?.accessibilityScanStarted;
            const shouldScanTestForAccessibility = this._testMetadata[uniqueId]?.scanTestForAccessibility;
            if (!accessibilityScanStarted) {
                return;
            }
            if (shouldScanTestForAccessibility) {
                log.info('Automate test case execution has ended. Processing for accessibility testing is underway. ');
            }
            const dataForExtension = {
                saveResults: shouldScanTestForAccessibility,
                testDetails: {
                    'name': pickleData.name,
                    'testRunId': process.env.BS_A11Y_TEST_RUN_ID,
                    'filePath': gherkinDocument.uri,
                    'scopeList': [featureData?.name, pickleData.name]
                },
                platform: this._platformA11yMeta
            };
            await this.sendTestStopEvent(this._browser, dataForExtension);
            if (shouldScanTestForAccessibility) {
                log.info('Accessibility testing for this test case has ended.');
            }
        }
        catch (error) {
            log.error(`Accessibility results could not be processed for the test case ${pickleData.name}. Error :`, error);
        }
    }
    /*
     * private methods
     */
    sendTestStartEvent(browser) {
        return browser.executeAsync(testStartEvent);
    }
    sendTestForceStopEvent(browser) {
        return browser.execute(testForceStop);
    }
    sendTestStopEvent(browser, dataForExtension) {
        return browser.executeAsync(testStop, dataForExtension);
    }
    getIdentifier(test) {
        if ('pickle' in test) {
            return getUniqueIdentifierForCucumber(test);
        }
        return getUniqueIdentifier(test, this._framework);
    }
    shouldRunTestHooks(browser, isAccessibility) {
        if (!browser) {
            return false;
        }
        return isBrowserstackSession(browser) && isAccessibilityAutomationSession(isAccessibility);
    }
    async checkIfPageOpened(browser, testIdentifier, shouldScanTest) {
        let pageOpen = false;
        this._testMetadata[testIdentifier] = {
            scanTestForAccessibility: shouldScanTest,
            accessibilityScanStarted: true
        };
        try {
            const currentURL = await browser.getUrl();
            const url = new URL(currentURL);
            pageOpen = url?.protocol === 'http:' || url?.protocol === 'https:';
        }
        catch (e) {
            pageOpen = false;
        }
        return pageOpen;
    }
}
// https://github.com/microsoft/TypeScript/issues/6543
const AccessibilityHandler = o11yClassErrorHandler(_AccessibilityHandler);
export default AccessibilityHandler;
