import path from 'node:path';
import logger from '@wdio/logger';
import WDIOReporter from '@wdio/reporter';
import * as url from 'node:url';
import { v4 as uuidv4 } from 'uuid';
import { getCloudProvider, uploadEventData, o11yClassErrorHandler, getGitMetaData, removeAnsiColors, getHookType, pushDataToQueue } from './util.js';
import RequestQueueHandler from './request-handler.js';
const log = logger('@wdio/browserstack-service');
class _TestReporter extends WDIOReporter {
    _capabilities = {};
    _config;
    _observability = true;
    _sessionId;
    _suiteName;
    _requestQueueHandler = RequestQueueHandler.getInstance();
    _suites = [];
    static _tests = {};
    _gitConfigPath;
    _gitConfigured = false;
    _currentHook = {};
    _currentTest = {};
    async onRunnerStart(runnerStats) {
        this._capabilities = runnerStats.capabilities;
        this._config = runnerStats.config;
        this._sessionId = runnerStats.sessionId;
        if (typeof this._config.testObservability !== 'undefined') {
            this._observability = this._config.testObservability;
        }
        await this.configureGit();
        this.registerListeners();
    }
    registerListeners() {
        if (this._config?.framework !== 'jasmine') {
            return;
        }
        process.removeAllListeners(`bs:addLog:${process.pid}`);
        process.on(`bs:addLog:${process.pid}`, this.appendTestItemLog.bind(this));
    }
    async appendTestItemLog(stdLog) {
        if (this._currentHook.uuid && !this._currentHook.finished) {
            stdLog.hook_run_uuid = this._currentHook.uuid;
        }
        else if (this._currentTest.uuid) {
            stdLog.test_run_uuid = this._currentTest.uuid;
        }
        if (stdLog.hook_run_uuid || stdLog.test_run_uuid) {
            await pushDataToQueue({
                event_type: 'LogCreated',
                logs: [stdLog]
            });
        }
    }
    setCurrentHook(hookDetails) {
        if (hookDetails.finished) {
            if (this._currentHook.uuid === hookDetails.uuid) {
                this._currentHook.finished = true;
            }
            return;
        }
        this._currentHook = {
            uuid: hookDetails.uuid,
            finished: false
        };
    }
    async configureGit() {
        if (this._gitConfigured) {
            return;
        }
        const gitMeta = await getGitMetaData();
        if (gitMeta) {
            this._gitConfigPath = gitMeta.root;
        }
        this._gitConfigured = true;
    }
    static getTests() {
        return _TestReporter._tests;
    }
    onSuiteStart(suiteStats) {
        let filename = suiteStats.file;
        if (this._config?.framework === 'jasmine') {
            try {
                if (suiteStats.file.startsWith('file://')) {
                    filename = url.fileURLToPath(suiteStats.file);
                }
                if (filename === 'unknown spec file') {
                    // Sometimes in cases where a file has two suites. Then the file name be unknown for second suite, so getting the filename from first suite
                    filename = this._suiteName || suiteStats.file;
                }
            }
            catch (e) {
                log.debug('Error in decoding file name of suite');
            }
        }
        this._suiteName = filename;
        this._suites.push(suiteStats);
    }
    onSuiteEnd() {
        this._suites.pop();
    }
    needToSendData(testType, event) {
        if (!this._observability) {
            return false;
        }
        switch (this._config?.framework) {
            case 'mocha':
                return event === 'skip';
            case 'cucumber':
                return false;
            case 'jasmine':
                return event !== 'skip';
            default:
                return false;
        }
    }
    async onTestEnd(testStats) {
        if (!this.needToSendData('test', 'end')) {
            return;
        }
        if (testStats.fullTitle === '<unknown test>') {
            return;
        }
        testStats.end ||= new Date();
        await this.sendTestRunEvent(testStats, 'TestRunFinished');
    }
    async onTestStart(testStats) {
        if (!this.needToSendData('test', 'start')) {
            return;
        }
        if (testStats.fullTitle === '<unknown test>') {
            return;
        }
        const uuid = uuidv4();
        this._currentTest.uuid = uuid;
        _TestReporter._tests[testStats.fullTitle] = {
            uuid: uuid,
        };
        await this.sendTestRunEvent(testStats, 'TestRunStarted');
    }
    async onHookStart(hookStats) {
        if (!this.needToSendData('hook', 'start')) {
            return;
        }
        const identifier = this.getHookIdentifier(hookStats);
        const hookId = uuidv4();
        this.setCurrentHook({ uuid: hookId });
        _TestReporter._tests[identifier] = {
            uuid: hookId,
            startedAt: (new Date()).toISOString()
        };
        await this.sendTestRunEvent(hookStats, 'HookRunStarted');
    }
    async onHookEnd(hookStats) {
        if (!this.needToSendData('hook', 'end')) {
            return;
        }
        const identifier = this.getHookIdentifier(hookStats);
        if (_TestReporter._tests[identifier]) {
            _TestReporter._tests[identifier].finishedAt = (new Date()).toISOString();
        }
        else {
            _TestReporter._tests[identifier] = {
                finishedAt: (new Date()).toISOString()
            };
        }
        this.setCurrentHook({ uuid: _TestReporter._tests[identifier].uuid, finished: true });
        if (!hookStats.state && !hookStats.error) {
            hookStats.state = 'passed';
        }
        await this.sendTestRunEvent(hookStats, 'HookRunFinished');
    }
    getHookIdentifier(hookStats) {
        return `${hookStats.title} for ${this._suites.at(-1)?.title}`;
    }
    async onTestSkip(testStats) {
        // cucumber steps call this method. We don't want step skipped state so skip for cucumber
        if (!this.needToSendData('test', 'skip')) {
            return;
        }
        testStats.start ||= new Date();
        testStats.end ||= new Date();
        await this.sendTestRunEvent(testStats, 'TestRunSkipped');
    }
    async sendTestRunEvent(testStats, eventType) {
        const framework = this._config?.framework;
        const scopes = this._suites.map(s => s.title);
        const identifier = testStats.type === 'test' ? testStats.fullTitle : this.getHookIdentifier(testStats);
        const testMetaData = _TestReporter._tests[identifier];
        const scope = testStats.type === 'test' ? testStats.fullTitle : `${this._suites[0].title} - ${testStats.title}`;
        await this.configureGit();
        const testData = {
            uuid: testMetaData ? testMetaData.uuid : uuidv4(),
            type: testStats.type,
            name: testStats.title,
            body: {
                lang: 'webdriverio',
                code: null
            },
            scope: scope,
            scopes: scopes,
            identifier: identifier,
            file_name: this._suiteName ? path.relative(process.cwd(), this._suiteName) : undefined,
            location: this._suiteName ? path.relative(process.cwd(), this._suiteName) : undefined,
            vc_filepath: (this._gitConfigPath && this._suiteName) ? path.relative(this._gitConfigPath, this._suiteName) : undefined,
            started_at: testStats.start && testStats.start.toISOString(),
            finished_at: testStats.end && testStats.end.toISOString(),
            framework: framework,
            duration_in_ms: testStats._duration,
            result: testStats.state,
        };
        if (testStats.type === 'test') {
            testData.retries = { limit: testStats.retries || 0, attempts: testStats.retries || 0 };
        }
        if (eventType.startsWith('TestRun') || eventType === 'HookRunStarted') {
            /* istanbul ignore next */
            const cloudProvider = getCloudProvider({ options: { hostname: this._config?.hostname } });
            testData.integrations = {};
            /* istanbul ignore next */
            testData.integrations[cloudProvider] = {
                capabilities: this._capabilities,
                session_id: this._sessionId,
                browser: this._capabilities?.browserName,
                browser_version: this._capabilities?.browserVersion,
                platform: this._capabilities?.platformName,
            };
        }
        if (eventType === 'TestRunFinished' || eventType === 'HookRunFinished') {
            const { error } = testStats;
            const failed = testStats.state === 'failed';
            if (failed) {
                testData.result = (error && error.message && error.message.includes('sync skip; aborting execution')) ? 'ignore' : 'failed';
                if (error && testData.result !== 'skipped') {
                    testData.failure = [{ backtrace: [removeAnsiColors(error.message)] }]; // add all errors here
                    testData.failure_reason = removeAnsiColors(error.message);
                    testData.failure_type = error.message === null ? null : error.message.toString().match(/AssertionError/) ? 'AssertionError' : 'UnhandledError'; //verify if this is working
                }
            }
        }
        if (eventType === 'TestRunSkipped') {
            eventType = 'TestRunFinished';
        }
        const uploadData = {
            event_type: eventType,
        };
        if (eventType.match(/HookRun/)) {
            testData.hook_type = testData.name?.toLowerCase() ? getHookType(testData.name.toLowerCase()) : 'undefined';
            uploadData.hook_run = testData;
        }
        else {
            uploadData.test_run = testData;
        }
        const req = this._requestQueueHandler.add(uploadData);
        if (req.proceed && req.data) {
            await uploadEventData(req.data, req.url);
        }
    }
}
// https://github.com/microsoft/TypeScript/issues/6543
const TestReporter = o11yClassErrorHandler(_TestReporter);
export default TestReporter;
